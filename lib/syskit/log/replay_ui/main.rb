# frozen_string_literal: true

require "Qt"

module Syskit
    module Log
        # Replay UI
        #
        # The replay UI is implemented as a Qt .ui file that is dynamically loaded.
        # This ReplayUI::Functions implements extensions to this dynamically-generated
        # class, and ReplayUI is the public API (e.g. {ReplayUI.new})
        module ReplayUI
            def self.new(replay_manager = global_replay_manager, parent: nil)
                form = Vizkit.load(File.join(__dir__, "main.ui"), parent)
                form.setObjectName("syskit-log Replay UI")
                geo = form.size
                geo.setHeight(260)
                form.resize(geo)

                short = Qt::Shortcut.new(Qt::KeySequence.new("Ctrl+R"), form)
                short.connect(SIGNAL("activated()")) do
                    form.refresh
                end

                form.extend Functions
                form.config(replay_manager)
                form
            end

            def self.global_replay_manager
                Roby.app.execution_engine.pocolog_replay_manager
            end

            # The ReplayUI is defined using Qt designer .ui file. This module is added
            # to the autogenerated class to actually perform the UI function
            module Functions
                def config(replay_manager)
                    @replay_manager = replay_manager
                    @playing = false
                    @replay_speed = 1.0

                    @pause_icon = load_icon "pause"
                    @play_icon = load_icon "play"

                    config_timeline
                    config_buttons
                    config_target_speed
                    config_current_port_actions

                    @handler_id = replay_manager.execution_engine.add_side_work_handler(
                        description: "syskit-pocolog replay UI handler"
                    ) do
                        work_callback
                    end
                    display_info
                end

                attr_accessor :replay_speed

                def load_icon(name)
                    Qt::Icon.new(File.join(__dir__, "#{name}.png"))
                end

                def config_index_edit
                    index.connect SIGNAL("editingFinished()") do
                        if @replay_manager.sample_index != index.value && !playing?
                            @playing = true
                            seek_to(index.value)
                        end
                    end
                end

                def config_current_port_actions
                    actionNone.connect(SIGNAL("triggered(bool)")) do |checked|
                        if checked
                            actionCurrent_Port.setChecked(false)
                        else
                            actionNone.setChecked(true)
                        end
                    end

                    actionCurrent_Port.connect(SIGNAL("triggered(bool)")) do |checked|
                        if checked
                            actionNone.setChecked(false)
                        else
                            actionCurrent_Port.setChecked(true)
                        end
                    end
                end

                def config_target_speed
                    dtarget_speed.connect(SIGNAL("valueChanged(double)")) do |speed|
                        @replay_speed = speed
                    end
                end

                def config_buttons
                    bnext.connect(SIGNAL("clicked()"), self, :bnext_clicked)
                    bback.connect(SIGNAL("clicked()"), self, :bback_clicked)
                    bstop.connect(SIGNAL("clicked()"), self, :bstop_clicked)
                    bplay.connect(SIGNAL("clicked()"), self, :bplay_clicked)
                end

                def config_timeline
                    config_start_marker
                    config_end_marker
                    config_index_slider
                    timeline.setStepSize(1)
                    timeline.setSliderIndex(@replay_manager.sample_index)
                end

                def config_start_marker
                    connect(timeline, SIGNAL("startMarkerMoved(int)"),
                            index, SLOT("setValue(int)"))
                    timeline.connect(SIGNAL("startMarkerReleased(int)")) do |_value|
                        index.setValue(@replay_manager.sample_index)
                    end
                end

                def config_end_marker
                    connect(timeline, SIGNAL("endMarkerMoved(int)"),
                            index, SLOT("setValue(int)"))
                    timeline.connect(SIGNAL("endMarkerReleased(int)")) do |_value|
                        index.setValue(@replay_manager.sample_index)
                    end
                end

                def config_index_slider
                    connect(timeline, SIGNAL("indexSliderMoved(int)"),
                            index, SLOT("setValue(int)"))
                    timeline.connect(
                        SIGNAL("indexSliderReleased(int)"),
                        self, :slider_released
                    )
                    timeline.connect SIGNAL("indexSliderClicked()") do
                        bplay_clicked if playing?
                    end
                end

                def work_callback
                    $qApp.processEvents # rubocop:disable Style/GlobalVars
                    $qApp.sendPostedEvents # rubocop:disable Style/GlobalVars

                    if timeline.steps != @replay_manager.size_in_samples
                        update_sample_size
                    end

                    return unless @playing

                    @replay_manager.process_in_realtime(@replay_speed) if @playing
                    timeline.setSliderIndex(@replay_manager.sample_index)
                    display_info
                end

                def update_sample_size
                    timeline.setSteps(@replay_manager.size_in_samples)
                    index.setMaximum(@replay_manager.size_in_samples)
                    # setSliderIndex applies the setSteps change above
                    timeline.setSliderIndex(@replay_manager.sample_index)
                end

                def display_info
                    index.setValue([@replay_manager.sample_index, 0].max)
                    last_port.text = @replay_manager.last_replayed_stream_name || ""

                    current_time = @replay_manager.time
                    unless current_time
                        timestamp.text = "0"
                        return
                    end

                    timestamp.text =
                        @replay_manager.time.strftime("%a %D %H:%M:%S") +
                        format(".%<usec>06d", usec: current_time.tv_usec)
                end

                def dispose
                    @replay_manager.execution_engine.remove_side_work_handler(@handler_id)
                    @handler_id = nil
                end

                def slider_released(_index)
                    @replay_manager.seek(timeline.getSliderIndex)
                    display_info
                end

                def playing?
                    @playing
                end

                def bnext_clicked
                    if playing?
                        @replay_speed *= 2.0
                    else
                        @replay_manager.step
                        timeline.setSliderIndex(@replay_manager.sample_index)
                    end

                    display_info
                end

                def bback_clicked
                    if playing?
                        @replay_speed /= 2.0
                    else
                        @replay_manager.step_back
                        timeline.setSliderIndex(@replay_manager.sample_index)
                    end
                    display_info
                end

                def bstop_clicked
                    return unless playing?

                    stop
                    rewind
                end

                def seek_to(index)
                    if index.kind_of?(Time)
                        @replay_manager.seek(index)
                        timeline.setSliderIndex(@replay_manager.sample_index)
                        display_info
                    else
                        timeline.setSliderIndex index
                        slider_released(index)
                    end
                end

                def rewind
                    @replay_manager.rewind
                    timeline.setSliderIndex(@replay_manager.sample_index)
                    display_info
                end

                def play
                    resume
                end

                def stop
                    pause
                    rewind
                end

                def resume
                    bplay.icon = @pause_icon
                    @replay_manager.reset_replay_base_times
                    @playing = true
                end

                def pause
                    bplay.icon = @play_icon
                    @playing = false
                end

                def bplay_clicked
                    if playing?
                        pause
                    else
                        resume
                    end
                end
            end
        end
    end
end
